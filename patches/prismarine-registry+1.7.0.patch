diff --git a/node_modules/prismarine-registry/lib/pc/index.js b/node_modules/prismarine-registry/lib/pc/index.js
index e1fa7aa..d216724 100644
--- a/node_modules/prismarine-registry/lib/pc/index.js
+++ b/node_modules/prismarine-registry/lib/pc/index.js
@@ -5,13 +5,24 @@ nbt.float = value => ({ type: 'float', value })
 const { networkBiomesToMcDataSchema, mcDataSchemaToNetworkBiomes } = require('./transforms')
 
 module.exports = (data, staticData) => {
+  let id;
+  
   let hasDynamicDimensionData = false
 
   return {
     loadDimensionCodec (codec) {
       const dimensionCodec = nbt.simplify(codec)
       
-      const chat = dimensionCodec['minecraft:chat_type']?.value
+      const keys = Object.keys(dimensionCodec)
+
+      if (keys.length === 0) {
+        return // no dimension codec data
+      }
+
+      const hasMCPrefix = keys.some(key => key.startsWith('minecraft:'))
+      id = hasMCPrefix ? (name) => `minecraft:${name}` : (name) => name
+
+      const chat = dimensionCodec['minecraft:chat_type']?.value ?? dimensionCodec.chat_type?.value
       if (chat) {
         data.chatFormattingById = {}
         data.chatFormattingByName = {}
@@ -22,14 +33,15 @@ module.exports = (data, staticData) => {
             id: chatType.id,
             name: chatType.name,
             formatString: staticData.language[d.translation_key] || d.translation_key /* chat type minecraft:raw has the formatString given directly by the translation key */,
-            parameters: d.parameters
+            parameters: d.parameters,
+            style: d.style
           }
           data.chatFormattingById[chatType.id] = n
           data.chatFormattingByName[chatType.name] = n
         }
       }
 
-      const dimensions = dimensionCodec['minecraft:dimension_type']?.value
+      const dimensions = dimensionCodec['minecraft:dimension_type']?.value ?? dimensionCodec.dimension_type?.value
       if (dimensions) {
         data.dimensionsById = {}
         data.dimensionsByName = {}
@@ -45,7 +57,7 @@ module.exports = (data, staticData) => {
         }
       }
 
-      const biomes = dimensionCodec['minecraft:worldgen/biome']?.value
+      const biomes = dimensionCodec['minecraft:worldgen/biome']?.value ?? dimensionCodec['worldgen/biome']?.value
       if (!biomes) {
         return // no biome data
       }
@@ -77,8 +89,8 @@ module.exports = (data, staticData) => {
         // Keep the old dimension codec data if it exists (re-encoding)
         // We don't have this data statically, should probably be added to mcData
         if (data.dimensionsArray) {
-          codec['minecraft:dimension_type'] = nbt.comp({
-            type: nbt.string('minecraft:dimension_type'),
+          codec[id('dimension_type')] = nbt.comp({
+            type: nbt.string(id('dimension_type')),
             value: nbt.list(nbt.comp(
               data.dimensionsArray.map(dimension => ({
                 name: dimension.name,
@@ -88,17 +100,17 @@ module.exports = (data, staticData) => {
             ))
           })
         } else {
-          codec['minecraft:dimension_type'] = staticData.loginPacket.dimensionCodec.value['minecraft:dimension_type']
+          codec[id('dimension_type')] = staticData.loginPacket.dimensionCodec.value[id('dimension_type')]
         }
 
         // if we have dynamic biome data (re-encoding), we can count on biome.effects
         // being in place. Otherwise, we need to use static data exclusively, e.g. flying squid.
-        codec['minecraft:worldgen/biome'] = nbt.comp({
-          type: nbt.string('minecraft:worldgen/biome'),
+        codec[id('worldgen/biome')] = nbt.comp({
+          type: nbt.string(id('worldgen/biome')),
           value: nbt.list(nbt.comp(mcDataSchemaToNetworkBiomes(hasDynamicDimensionData ? data.biomesArray : null, staticData)))
         })
         // 1.19
-        codec['minecraft:chat_type'] = staticData.loginPacket.dimensionCodec?.value?.['minecraft:chat_type']
+        codec[id('chat_type')] = staticData.loginPacket.dimensionCodec?.value?.[id('chat_type')]
       }
 
       return nbt.comp(codec)
